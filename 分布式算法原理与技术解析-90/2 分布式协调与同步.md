## 03 分布式互斥

分布式互斥 Distributed Mutual Exclusion

临界资源 Critical Resource



### 霸道总裁：集中式算法

> 引入一个协调者程序，得到一个分布式互斥算法。每个程序在需要访问临界资源时，先给协调者发送一个请求。如果当前没有程序使用这个资源，协调者直接授权请求程序访问；否则，按照先来后到的顺序为请求程序“排一个号”。如果有程序使用完资源，则通知协调者，协调者从“排号”的队列里取出排在最前面的请求，并给它发送授权消息。拿到授权消息的程序，可以直接去访问临界资源。

<img src="pic\集中式算法.png" alt="image-20210102203150297" style="zoom:50%;" />

> 每个程序完成一次临界资源访问，需要进行 3 次消息交互



所有程序只需和协调者通信，程序之间无需通信



优点

- 简单、易于实现

缺点 

- 协调者容易出现问题
  - 协调者会成为系统的性能瓶颈
    - 改进：选择性能好、可靠性高的服务器
  - 单点故障
    - 改进：集群（主从进行同步备份）



### 民主协商：分布式算法

> 当一个程序要访问临界资源时，先向系统中的其他程序发送一条请求消息，在接收到所有程序返回的同意消息后，才可以访问临界资源。其中，请求消息需要包含所请求的资源、请求者的 ID，以及发起请求的时间。

<img src="pic\分布式算法-1.png" alt="image-20210102204508358" style="zoom:50%;" />

<img src="pic\分布式算法-2.png" alt="image-20210102204529673" style="zoom:50%;" />

<img src="pic\分布式算法-3.png" alt="image-20210102204728717" style="zoom:50%;" />

信息交互：

1. 向其他 n-1 个程序发送访问临界资源的请求，总共需要 n-1 次消息交互
2. 接收到其他 n-1 个程序回复的同意消息，方可访问资源，总共需要 n-1 次消息交互

> 一个程序要成功访问临界资源，至少需要 2*(n-1) 次消息交互，消息数量会随着需要访问临界资源的程序数量呈指数级增加，容易导致高昂的 “沟通成本”



“先到先得”和“投票全票通过”两个机制，让每个程序按时间顺序公平地访问资源



优点：简单粗暴、易于实现

缺点：

- 通信成本高：当系统内需要访问临界资源的程序增多时，容易产生“信令风暴”，也就是程序收到的请求完全超过了自己的处理能力，而导致自己正常的业务无法开展。
  - 改进：半数同意
- 可用性很低：一旦某一程序发生故障，无法发送同意消息，那么其他程序均处在等待回复的状态中，使得整个系统处于停滞状态，导致整个系统不可用（我自己使用完之后，还没等回复，我就坏了，那么这个资源接下来不能再被继续使用）
  - 改进：如果检测到一个程序故障，则直接忽略这个程序，但这样每个程序都需要对其他程序进行故障检测，这无疑带来了更大的复杂性



**分布式算法适合节点数目少且变动不频繁的系统（临界资源使用频率较低），每个程序均需通信交互**



HDFS 的文件修改

<img src="pic\HDFS文件修改.png" alt="image-20210102210000530" style="zoom:50%;" />





### 轮值 CEO：令牌环算法

> 令牌按照顺时针（或逆时针）方向在程序之间传递，收到令牌的程序有权访问临界资源，访问完成后将令牌传送到下一个程序；若该程序不需要访问临界资源，则直接把令牌传送给下一个程序。

<img src="pic\令牌环算法.png" alt="image-20210102211218129" style="zoom:50%;" />

优点：不需要征求其他程序的意见，所以有更高的通信效率

缺点：

- 单点故障（也可通过 直接将令牌传递给故障程序的下一个程序 解决）
- 当临界资源使用较低时，会带来较多无用通信
  - 改进：增加权重，如不常访问的节点两轮访问一次



**适用于系统规模较小，并且系统中每个程序使用临界资源的频率高且使用时间比较短的场景**



适合大规模的分布式互斥算法：两层结构的分布式令牌环算法





-------------





<img src="pic\互斥算法总结.png" alt="image-20210102212054668" style="zoom: 50%;" />





## 04 分布式选举

为什么会有分布式选举？

- **集群不可一刻无主**
- 选出一个主节点，由它来协调和管理其他节点，以保证集群有序运行和节点间数据的一致性。



### 长者为大：Bully 算法



节点角色：普通节点和主节点

初始化时，所有节点都是平等的，都是普通节点，并且都有成为主的权利。但是，当选主成功后，有且仅有一个节点成为主节点，其他所有节点都是普通节点。当且仅当主节点故障或与其他节点失去联系后，才会重新选主。



选举过程中的3种信息：

- Election 消息，用于发起选举
- Alive 消息，对 Election 消息的应答
- Victory 消息，竞选成功的主节点向其他节点发送的宣誓主权的消息



选举条件：“长者为大”  （假设集群中每个节点均知道其他节点的ID）



<img src="pic\bully算法.png" alt="image-20210102215354098" style="zoom:50%;" />

1. 集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息，宣誓自己的主权；
2. 如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送 Election 消息，并等待其他节点的回复；
3. 若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。
4. 若在给定的时间范围内，本节点没有收到自己发送Election 的节点回复的 Alive 消息，则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；若接收到来自比自己 ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息；



MongoDB 的副本集故障转移

- 采用节点的最后操作时间戳来表示 ID，时间戳最新的节点其 ID 最大，也就是说时间戳最新的、活着的节点是主节点。



优点：选举速度快、算法复杂度低、简单易实现

缺点：

- 需要每个节点有全局的节点信息，因此额外信息存储较多
- 任意一个比当前主节点 ID 大的新节点或节点故障后恢复加入集群的时候，都可能会触发重新选举，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主



### 民主投票：Raft 算法

节点角色：

- Leader：即主节点，同一时刻只有一个 Leader，负责协调和管理其他节点
- Candidate：即候选者，每一个节点都可以成为 Candidate，节点在该角色下才可以被选为新的 Leader
- Follower：Leader 的跟随者，不可以发起选举



<img src="pic\raft算法.png" alt="image-20210102220344465" style="zoom:50%;" />

> term 是指选举周期

1. 初始化时，所有节点均为 Follower 状态
2. 开始选主时，所有节点的状态由 Follower 转化为 Candidate，并向其他节点发送选举请求。
3. 其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。**在每一轮选举中，一个节点只能投出一张票。**
4. 若发起选举请求的节点获得超过**一半**的投票，则成为主节点，其状态转化为 Leader，其他节点的状态则由 Candidate 降为 Follower。Leader 节点与 Follower 节点之间会定期发送心跳包，以检测主节点是否活着。
5. 当 Leader 节点的任期到了，即发现其他服务器开始下一轮选主周期时，Leader 节点的状态由 Leader 降级为 Follower，进入新一轮选主。

选主是周期进行的，包括选主和任值两个时间段，选主阶段对应投票阶段，任值阶段对应节点成为主之后的任期，但如果主节点故障，会立马发起选举，重新选出一个主节点



Kubernetes，为了保证可靠性，通常会部署 3 个节点用于数据备份，有一个会被选为主，其他节点作为备。Kubernetes 的选主采用的是开源的 etcd 组件，而 etcd 的集群管理器 etcds，是一个高可用、强一致性的服务发现存储仓库，就是采用了 Raft 算法来实现选主和一致性的。







优点：

- 选举速度快、算法复杂度低、易于实现
- 稳定性比 Bully 算法好（因为当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点获得投票数过半，才会导致切主。）

缺点：

- 要求系统内每个节点都可以相互通信，且需要获得过半的投票数才能选主成功，因此通信量大



### 具有优先级的民主投票：ZAB算法

ZooKeeper Atomic Broadcast： ZooKeeper 实现分布式协调功能而设计的



节点角色：

- Leader：主节点
- Follower：跟随者节点
- Observer：观察者，无投票权

节点状态：

- Looking：选举状态。当节点处于该状态时，它会认为当前集群中没有Leader，因此自己进入选举状态
- Leading：领导者状态。表示已经选择出主，且当前节点为leader
- Following：跟随着状态。集群中已经选出主后，其他非主节点状态更新为Following，表示对Leader的追随
- Observing：观察者状态，表示当前节点为Observer，持观望态度，没有投票权和选举权



相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。相比较于 Raft 算法，ZAB 算法尽可能保证数据的最新性。



少数服从多数，ID 大的节点优先成为主



每个节点都有一个唯一的三元组（epoch，server_id， server_zxID）

<img src="pic\ZAB算法-1.png" alt="image-20210103112639563" style="zoom:50%;" />

<img src="pic\ZAB算法-2.png"  style="zoom:50%;" />




<img src="pic\ZAB算法-3.png" alt="image-20210103112948203" style="zoom:50%;" />



优点：

- 稳定性比较好，当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点数据 ID 和节点 ID 最大，且获得投票数过半，才会导致切主。

缺点：

- n个节点的集群，信息量为 n*(n-1) 个消息，容易出现广播风暴
- 除了投票，还增加了对比节点 ID 和数据 ID，这就意味着还需要知道所有节点的 ID 和数据 ID，所以选举时间相对较长







--------------

选举算法对比

![image-20210103113459323](pic\选举算法总结.png)



为什么“多数派”选主算法通常采用奇数节点，而不是偶数节点呢？

多数派选主算法的核心是少数服从多数，获得投票多的节点胜出。如果现在采用偶数节点集群，当两个节点均获得一半投票时，到底应该选谁为主呢？在这种情况下，无法选出主，必须重新投票选举。但即使重新投票选举，两个节点拥有相同投票数的概率也会很大。因此，多数派选主算法通常采用奇数节点。



<img src="pic\分布式选举.png" alt="image-20210103134707146" style="zoom:50%;" />



分布式选举和一致性的关系是什么？



你是否见过一个集群中存在双主的场景呢？





## 05 分布式共识：存异求同

分布式共识：在多个节点均可独自操作或记录的情况下，使得所有节点针对某个状态达成一致的过程

> 区块链



### PoW 

Proof-of-Work，工作量证明

谁的计算力强、工作能力强，谁获得记账权的可能性就越大。



> 利用区块的 index、前一个区块的哈希值、交易的时间戳、区块数据和 nonce 值，通过 SHA256 哈希算法计算出一个哈希值，并判断前 k 个值是否都为 0。如果不是，则递增 nonce 值，重新按照上述方法计算；如果是，则本次计算的哈希值为要解决的题目的正确答案。谁最先计算出正确答案，谁就获得这个区块的记账权。

nonce 值是用来找到一个满足哈希值的数字；k 为哈希值前导零的个数，标记了计算的难度，0 越多计算难度越大。



假设客户端 A 产生一个新的交易，基于 PoW 的共识记账过程为：

- 客户端 A 产生新的交易，向全网进行广播，要求对交易进行记账
- 每个记账节点接收到这个请求后，将收到的交易信息放入一个区块中
- 每个节点通过 PoW 算法，计算本节点的区块的哈希值，尝试找到一个具有足够工作量难度的工作量证明。
- 若节点 D 找到了一个工作量证明向全网广播。当然，当且仅当包含在该区块中的交易都是有效且之前未存在过的，其他节点才会认同该区块的有效性。
- 其他节点接收到广播信息后，若该区块有效，接受该区块，并跟随在该区块的末尾，制造新区块延长该链条，将被接受的区块的随机哈希值视为新区块的随机哈希值。

![image-20210109204953911](pic\pof算法.png)

> 比特币平台采用了 PoW 算法，属于区块链 1.0 阶段，其重心在于货币，比特币大约 10min 才会产生一个区块，区块的大小也只有 1MB，仅能够包含 3000～4000 笔交易，平均每秒只能够处理 5~7（个位数）笔交易。



优点：容错性强（允许全网 50% 的节点出错）

缺点：

- 每次达成共识需要全网共同参与运算，增加了每个节点的计算量
- 共识达成的周期长、效率低，资源消耗大：
  - 如果题目过难，会导致计算时间长、资源消耗多；
  - 而如果题目过于简单，会导致大量节点同时获得记账权，冲突多。



### PoS

Proof-of-Stake，权益证明

由系统权益代替算力来决定区块记账权，拥有的权益越大获得记账权的概率就越大。

权益：就是每个节点占有货币的数量和时间，而货币就是节点所获得的奖励 （“利滚利”）



PoS 算法决定区块记账权的流程和 PoW 算法类似，唯一不同的就是，每个节点在计算自己记账权的时候，通过计算自己的股权或权益来评估，如果发现自己权益最大，则将自己的区块广播给其他节点，当然必须保证该区块的有效性。

![image-20210109210154625](pic\pos.png)



> 以太坊平台属于区块链 2.0 阶段，在区块链 1.0 的基础上进一步强调了合约，采用了 PoS 算法。12 年发布的点点币（PPC），综合了 PoW 工作量证明及 PoS 权益证明方式，从而在安全和节能方面实现了创新。



优点：

- 不需要消耗大量的电力就能够保证区块链网络的安全性
- 不需要在每个区块中创建新的货币来激励记账者参与当前网络的运行，这也就在一定程度上缩短了达成共识所需要的时间。（以太坊每秒大概能处理 30 笔左右的交易）

缺点：

- 持币越多或持币越久，币龄就会越高，持币人就越容易挖到区块并得到激励，而持币少的人基本没有机会，容易出现垄断现象





### DPoS

Delegated Proof of Stake，委托权益证明

DPoS 算法的原理，类似股份制公司的董事会制度，普通股民虽然拥有股权，但进不了董事会，他们可以投票选举代表（受托人）代他们做决策。DPoS 是由被社区选举的可信帐户（受托人，比如得票数排行前 101 位）来拥有记账权。



![image-20210109211943426](pic\DPoS.png)

在 DPos 算法中，通常会选出 k (比如 101) 个受托节点，它们的权利是完全相等的。受托节点之间争取记账权也是根据算力进行竞争的。只要受托节点提供的算力不稳定，计算机宕机或者利用手中的权力作恶，随时可以被握着货币的普通节点投票踢出整个系统，而后备的受托节点可以随时顶上去。

> DPoS 在比特股和 Steem 上已运行多年，被称为区块链 3.0 阶段



优点：

- DPoS 能耗更低，具有更快的交易速度：由投票选举出的若干信誉度更高的受托人记账，解决了所有节点均参与竞争导致消息量大、达成一致的周期长的问题。
- 每隔一定周期会调整受托人，避免受托人造假和独权

缺点：

- 大多数持币人通过受托人参与投票，投票的积极性并不高





-------------

![image-20210109212357036](pic\分布式共识算法.png)



一致性与共识的区别是什么？

**一致性**：分布式系统的多个节点之间，给定一系列的操作，在约定协议的保障下，对外界呈现的数据或状态时一致的

**共识：**分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程

> 一致性强调的是结果，共识强调的是达成一致性的过程，共识算法是保障系统满足不同程度一致性的核心技术



## 06 分布式事务 All or nothing

事务的特征

- 原子性（Atomicity）：事务最终的状态只有两种，全部执行成功和全部不执行
- 一致性（Consistency）：事务操作前和操作后，数据的完整性保持一致或满足完整性约束
- 隔离性（Isolation）：有多个事务并发执行时，多个事务不会相互干扰
- 持久性（Durability）：一个事务完成了，那么它对数据库所做的更新就被永久保存下来了



分布式事务主要是解决在分布式环境下，组合事务的一致性问题



### 基于 XA 协议的二阶段提交方法

XA 是一个分布式事务协议，规定了事务管理器和资源管理器接口。

事务管理器作为协调者，负责各个本地资源的提交和回滚；

资源管理器就是分布式事务的参与者，通常由数据库实现，比如 Oracle、DB2 等商业数据库都实现了 XA 接口





二阶段提交协议（The two-phase commit protocol，2PC）：保证分布式系统中事务提交时的数据一致性，是 XA 在全局事务中用于协调多个资源的机制。为了保证它们的一致性，我们需要引入一个协调者来管理所有的节点，并确保这些节点正确提交操作结果，若提交失败则放弃事务。

1. voting
   - 协调者（Coordinator，即事务管理器）会向事务的参与者（Cohort，即本地资源管理器）发起执行操作的 CanCommit 请求，并等待参与者的响应
   - 参与者接收到请求后，会执行请求中的事务操作，记录日志信息但不提交，待参与者执行成功，则向协调者发送“Yes”消息，表示同意操作；若不成功，则发送“No”消息，表示终止操作。
   - 当所有的参与者都返回了操作结果（Yes 或 No 消息）后，**系统才进入提交阶段**

1. commit 
   - 协调者会根据所有参与者返回的信息向参与者发送 DoCommit 或 DoAbort 指令
   - 若协调者收到的都是“Yes”消息，则向参与者发送“DoCommit”消息，参与者会完成剩余的操作并释放资源，然后向协调者返回“HaveCommitted”消息；
   - 如果协调者收到的消息中包含“No”消息，则向所有参与者发送“DoAbort”消息，此时发送“Yes”的参与者则会根据之前执行操作时的回滚日志对操作进行回滚，然后所有参与者会向协调者发送“HaveCommitted”消息；
   - 协调者接收到“HaveCommitted”消息，就意味着整个事务结束了。

> e.g. 下单 & 减库存
>
> 用户 A 要在网上下单购买 100 件 T 恤

第一阶段： 订单系统中将与用户 A 有关的订单数据库锁住，准备好增加一条关于用户 A 购买 100 件 T 恤的信息，并将同意消息“Yes”回复给协调者。而库存系统由于 T 恤库存不足，出货失败，因此向协调者回复了一个终止消息“No”。

<img src="pic\基于XA的两阶段提交方法-1.png" alt="image-20210109220210451" style="zoom:50%;" />

第二阶段：由于库存系统操作不成功，因此，协调者就会向订单系统和库存系统发送“DoAbort”消息。订单系统接收到“DoAbort”消息后，将系统内的数据退回到没有用户 A 购买 100 件 T 恤的版本，并释放锁住的数据库资源。订单系统和库存系统完成操作后，向协调者发送“HaveCommitted”消息，表示完成了事务的撤销操作。

<img src="pic\基于XA的两阶段提交方法-2.png" alt="image-20210109220343601" style="zoom:50%;" />

**算法思路**：协调者下发请求事务操作，参与者将操作结果通知协调者，协调者根据所有参与者的反馈结果决定各参与者是要提交操作还是撤销操作。



优点：基本满足了事务的 ACID 特性

缺点：

- 同步阻塞问题：所有参与节点都是事务阻塞型的
- 单点故障问题：一旦事务管理器发生故障，整个系统都处于停滞状态。尤其是在提交阶段，一旦事务管理器发生故障，资源管理器会由于等待管理器的消息，而一直锁定事务资源，导致整个系统被阻塞。
- 数据不一致问题：在提交阶段，当协调者向参与者发送 DoCommit 请求之后，如果发生了局部网络异常，或者在发送提交请求的过程中协调者发生了故障，就会导致只有一部分参与者接收到了提交请求并执行提交操作，但其他未接到提交请求的那部分参与者则无法执行事务提交。于是整个分布式系统便出现了数据不一致的问题。

