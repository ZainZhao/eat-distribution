## 03 分布式互斥

分布式互斥 Distributed Mutual Exclusion

临界资源 Critical Resource



### 霸道总裁：集中式算法

> 引入一个协调者程序，得到一个分布式互斥算法。每个程序在需要访问临界资源时，先给协调者发送一个请求。如果当前没有程序使用这个资源，协调者直接授权请求程序访问；否则，按照先来后到的顺序为请求程序“排一个号”。如果有程序使用完资源，则通知协调者，协调者从“排号”的队列里取出排在最前面的请求，并给它发送授权消息。拿到授权消息的程序，可以直接去访问临界资源。

<img src="pic\集中式算法.png" alt="image-20210102203150297" style="zoom:50%;" />

> 每个程序完成一次临界资源访问，需要进行 3 次消息交互



所有程序只需和协调者通信，程序之间无需通信



优点

- 简单、易于实现

缺点 

- 协调者容易出现问题
  - 协调者会成为系统的性能瓶颈
    - 改进：选择性能好、可靠性高的服务器
  - 单点故障
    - 改进：集群（主从进行同步备份）



### 民主协商：分布式算法

> 当一个程序要访问临界资源时，先向系统中的其他程序发送一条请求消息，在接收到所有程序返回的同意消息后，才可以访问临界资源。其中，请求消息需要包含所请求的资源、请求者的 ID，以及发起请求的时间。

<img src="pic\分布式算法-1.png" alt="image-20210102204508358" style="zoom:50%;" />

<img src="pic\分布式算法-2.png" alt="image-20210102204529673" style="zoom:50%;" />

<img src="pic\分布式算法-3.png" alt="image-20210102204728717" style="zoom:50%;" />

信息交互：

1. 向其他 n-1 个程序发送访问临界资源的请求，总共需要 n-1 次消息交互
2. 接收到其他 n-1 个程序回复的同意消息，方可访问资源，总共需要 n-1 次消息交互

> 一个程序要成功访问临界资源，至少需要 2*(n-1) 次消息交互，消息数量会随着需要访问临界资源的程序数量呈指数级增加，容易导致高昂的 “沟通成本”



“先到先得”和“投票全票通过”两个机制，让每个程序按时间顺序公平地访问资源



优点：简单粗暴、易于实现

缺点：

- 通信成本高：当系统内需要访问临界资源的程序增多时，容易产生“信令风暴”，也就是程序收到的请求完全超过了自己的处理能力，而导致自己正常的业务无法开展。
  - 改进：半数同意
- 可用性很低：一旦某一程序发生故障，无法发送同意消息，那么其他程序均处在等待回复的状态中，使得整个系统处于停滞状态，导致整个系统不可用（我自己使用完之后，还没等回复，我就坏了，那么这个资源接下来不能再被继续使用）
  - 改进：如果检测到一个程序故障，则直接忽略这个程序，但这样每个程序都需要对其他程序进行故障检测，这无疑带来了更大的复杂性



**分布式算法适合节点数目少且变动不频繁的系统（临界资源使用频率较低），每个程序均需通信交互**



HDFS 的文件修改

<img src="pic\HDFS文件修改.png" alt="image-20210102210000530" style="zoom:50%;" />





### 轮值 CEO：令牌环算法

> 令牌按照顺时针（或逆时针）方向在程序之间传递，收到令牌的程序有权访问临界资源，访问完成后将令牌传送到下一个程序；若该程序不需要访问临界资源，则直接把令牌传送给下一个程序。

<img src="pic\令牌环算法.png" alt="image-20210102211218129" style="zoom:50%;" />

优点：不需要征求其他程序的意见，所以有更高的通信效率

缺点：

- 单点故障（也可通过 直接将令牌传递给故障程序的下一个程序 解决）
- 当临界资源使用较低时，会带来较多无用通信
  - 改进：增加权重，如不常访问的节点两轮访问一次



**适用于系统规模较小，并且系统中每个程序使用临界资源的频率高且使用时间比较短的场景**



适合大规模的分布式互斥算法：两层结构的分布式令牌环算法





-------------





<img src="pic\互斥算法总结.png" alt="image-20210102212054668" style="zoom: 50%;" />





## 04 分布式选举

为什么会有分布式选举？

- **集群不可一刻无主**
- 选出一个主节点，由它来协调和管理其他节点，以保证集群有序运行和节点间数据的一致性。



### 长者为大：Bully 算法



节点角色：普通节点和主节点

初始化时，所有节点都是平等的，都是普通节点，并且都有成为主的权利。但是，当选主成功后，有且仅有一个节点成为主节点，其他所有节点都是普通节点。当且仅当主节点故障或与其他节点失去联系后，才会重新选主。



选举过程中的3种信息：

- Election 消息，用于发起选举
- Alive 消息，对 Election 消息的应答
- Victory 消息，竞选成功的主节点向其他节点发送的宣誓主权的消息



选举条件：“长者为大”  （假设集群中每个节点均知道其他节点的ID）



<img src="pic\bully算法.png" alt="image-20210102215354098" style="zoom:50%;" />

1. 集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息，宣誓自己的主权；
2. 如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送 Election 消息，并等待其他节点的回复；
3. 若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。
4. 若在给定的时间范围内，本节点没有收到自己发送Election 的节点回复的 Alive 消息，则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；若接收到来自比自己 ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息；



MongoDB 的副本集故障转移

- 采用节点的最后操作时间戳来表示 ID，时间戳最新的节点其 ID 最大，也就是说时间戳最新的、活着的节点是主节点。



优点：选举速度快、算法复杂度低、简单易实现

缺点：

- 需要每个节点有全局的节点信息，因此额外信息存储较多
- 任意一个比当前主节点 ID 大的新节点或节点故障后恢复加入集群的时候，都可能会触发重新选举，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主



### 民主投票：Raft 算法

节点角色：

- Leader：即主节点，同一时刻只有一个 Leader，负责协调和管理其他节点
- Candidate：即候选者，每一个节点都可以成为 Candidate，节点在该角色下才可以被选为新的 Leader
- Follower：Leader 的跟随者，不可以发起选举



<img src="pic\raft算法.png" alt="image-20210102220344465" style="zoom:50%;" />

> term 是指选举周期

1. 初始化时，所有节点均为 Follower 状态
2. 开始选主时，所有节点的状态由 Follower 转化为 Candidate，并向其他节点发送选举请求。
3. 其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。**在每一轮选举中，一个节点只能投出一张票。**
4. 若发起选举请求的节点获得超过**一半**的投票，则成为主节点，其状态转化为 Leader，其他节点的状态则由 Candidate 降为 Follower。Leader 节点与 Follower 节点之间会定期发送心跳包，以检测主节点是否活着。
5. 当 Leader 节点的任期到了，即发现其他服务器开始下一轮选主周期时，Leader 节点的状态由 Leader 降级为 Follower，进入新一轮选主。

选主是周期进行的，包括选主和任值两个时间段，选主阶段对应投票阶段，任值阶段对应节点成为主之后的任期，但如果主节点故障，会立马发起选举，重新选出一个主节点



Kubernetes，为了保证可靠性，通常会部署 3 个节点用于数据备份，有一个会被选为主，其他节点作为备。Kubernetes 的选主采用的是开源的 etcd 组件，而 etcd 的集群管理器 etcds，是一个高可用、强一致性的服务发现存储仓库，就是采用了 Raft 算法来实现选主和一致性的。





优点：

- 选举速度快、算法复杂度低、易于实现
- 稳定性比 Bully 算法好（因为当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点获得投票数过半，才会导致切主。）

缺点：

- 要求系统内每个节点都可以相互通信，且需要获得过半的投票数才能选主成功，因此通信量大
- 

## 05 分布式共识